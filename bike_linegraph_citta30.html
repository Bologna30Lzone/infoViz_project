<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Andamento Flusso Bike Bologna (2019+)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .axis path, .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
    .line { fill: none; stroke: steelblue; stroke-width: 2px; }
    .trend { fill: none; stroke: tomato; stroke-width: 2px; stroke-dasharray: 5,5; }
    .point { fill: steelblue; stroke: #fff; stroke-width: 1px; }
    .marker-line { stroke: gray; stroke-width: 1px; stroke-dasharray: 4,2; }
    .marker-label { fill: gray; font-size: 12px; text-anchor: start; }
    .no-data { fill: red; font-size: 16px; }
    .buttons { margin: 10px; }
    .buttons button { margin-right: 5px; padding: 5px 10px; cursor: pointer; }
    .active { background-color: #ddd; }
    .tooltip {
      position: absolute;
      background: rgba(255,255,255,0.9);
      padding: 5px 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <svg id="chart" width="960" height="500"></svg>
  <div class="buttons">
    <button data-res="quarterly" class="active">Quarterly</button>
    <button data-res="semiannual">Semiannual</button>
    <button data-res="yearly">Yearly</button>
  </div>
  <div class="tooltip"></div>
  <script>
    const svg = d3.select('#chart'),
          margin = { top: 20, right: 30, bottom: 50, left: 60 },
          width = +svg.attr('width') - margin.left - margin.right,
          height = +svg.attr('height') - margin.top - margin.bottom;

    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
    const tooltip = d3.select('.tooltip');

    const parseDate = d3.timeParse('%Y-%m-%d');
    const fmtMonth = d3.timeFormat('%b');

    const selectedStations = new Set(['Ercolani', 'Sabotino', 'San Donato']);
    const startDate = parseDate('2019-01-01');
    const markerDate = parseDate('2024-01-01');

    let filteredData, globalXDomain, globalYDomain;
    let trendEnds;
    let xScale, yScale, xAxisGroup, yAxisGroup;
    let linePath, trendPath, pointGroup;
    let currentRes = 'quarterly';

    d3.csv('bike-trimmed.csv').then(rawData => {
      // filter and parse
      const dataAll = rawData.map(d => ({
        date: parseDate(d.data),
        value: +d.totale,
        station: d.colonnina
      }));
      filteredData = dataAll.filter(d =>
        d.date && d.date >= startDate && d.value > 0 && selectedStations.has(d.station)
      );
      if (!filteredData.length) {
        svg.append('text')
          .attr('x', margin.left)
          .attr('y', margin.top)
          .attr('class', 'no-data')
          .text('Nessun dato disponibile per le stazioni selezionate.');
        return;
      }

      // global domains
      const dates = filteredData.map(d => d.date);
      globalXDomain = [startDate, d3.max(dates)];

      // helper to aggregate daily means then group
      function aggregate(res) {
        // group by period
        let rolled;
        if (res === 'quarterly') {
          rolled = d3.rollups(
            filteredData,
            v => d3.mean(v, d => d.value),
            d => {
              const y = d.date.getFullYear();
              const q = Math.floor(d.date.getMonth() / 3) + 1;
              return `${y}-Q${q}`;
            }
          ).map(([k, m]) => {
            const [y, q] = k.split('-Q');
            return { date: new Date(+y, (q - 1) * 3, 1), mean: m };
          });
        } else if (res === 'semiannual') {
          rolled = d3.rollups(
            filteredData,
            v => d3.mean(v, d => d.value),
            d => {
              const y = d.date.getFullYear();
              const h = Math.floor(d.date.getMonth() / 6) + 1;
              return `${y}-H${h}`;
            }
          ).map(([k, m]) => {
            const [y, h] = k.split('-H');
            return { date: new Date(+y, (h - 1) * 6, 1), mean: m };
          });
        } else {
          rolled = d3.rollups(
            filteredData,
            v => d3.mean(v, d => d.value),
            d => d.date.getFullYear()
          ).map(([k, m]) => ({ date: new Date(+k, 0, 1), mean: m }));
        }
        return rolled.sort((a, b) => d3.ascending(a.date, b.date));
      }

      // compute globalYDomain
      const allValues = [
        ...aggregate('quarterly').map(d => d.mean),
        ...aggregate('semiannual').map(d => d.mean),
        ...aggregate('yearly').map(d => d.mean)
      ];
      globalYDomain = [0, d3.max(allValues)];

      // compute trend on initial quarterly
      const initial = aggregate('quarterly');
      const xs = initial.map(d => d.date.getTime());
      const ys = initial.map(d => d.mean);
      const xm = d3.mean(xs), ym = d3.mean(ys);
      let num = 0, den = 0;
      initial.forEach(d => { const x = d.date.getTime(); num += (x - xm) * (d.mean - ym); den += (x - xm) ** 2; });
      const slope = den ? num / den : 0;
      const intercept = ym - slope * xm;
      trendEnds = [
        { date: initial[0].date, mean: intercept + slope * initial[0].date.getTime() },
        { date: initial[initial.length - 1].date, mean: intercept + slope * initial[initial.length - 1].date.getTime() }
      ];

      // Scales and axes
      xScale = d3.scaleTime().domain(globalXDomain).range([0, width]);
      yScale = d3.scaleLinear().domain(globalYDomain).nice().range([height, 0]);
      xAxisGroup = g.append('g').attr('transform', `translate(0,${height})`);
      yAxisGroup = g.append('g');

      const lineGen = d3.line()
        .curve(d3.curveLinear)
        .x(d => xScale(d.date))
        .y(d => yScale(d.mean));

      linePath = g.append('path').attr('class', 'line');
      trendPath = g.append('path').attr('class', 'trend').datum(trendEnds).attr('d', lineGen);
      pointGroup = g.append('g');

      // Marker
      const markerGroup = g.append('g').attr('class', 'marker-group');
      markerGroup.append('line').attr('class', 'marker-line').attr('y1', 0).attr('y2', height);
      markerGroup.append('text').attr('class', 'marker-label').attr('y', -5).text('CittÃ  30');

      d3.selectAll('.buttons button').on('click', function() {
        currentRes = d3.select(this).attr('data-res');
        d3.selectAll('.buttons button').classed('active', false);
        d3.select(this).classed('active', true);
        updateChart();
      });

      updateChart();

      function updateChart() {
        const data = aggregate(currentRes);
        // marker
        const mx = xScale(markerDate);
        markerGroup.select('.marker-line').attr('x1', mx).attr('x2', mx);
        markerGroup.select('.marker-label').attr('x', mx + 5);

        // axes
        let interval;
        if (currentRes === 'quarterly') interval = d3.timeMonth.every(3);
        else if (currentRes === 'semiannual') interval = d3.timeMonth.every(6);
        else interval = d3.timeYear.every(1);
        const ticks = interval.range(globalXDomain[0], globalXDomain[1]);
        xAxisGroup.transition().duration(800)
          .call(d3.axisBottom(xScale).tickValues(ticks).tickFormat(d => d.getMonth() === 0 ? d.getFullYear() : ''));
        yAxisGroup.transition().duration(800).call(d3.axisLeft(yScale));

        // line
        linePath.datum(data)
          .attr('d', lineGen)
          .attr('stroke-dasharray', function() { return this.getTotalLength(); })
          .attr('stroke-dashoffset', function() { return this.getTotalLength(); })
          .transition().duration(1000).attr('stroke-dashoffset', 0);

        // points
        const pts = pointGroup.selectAll('circle').data(data, d => +d.date);
        pts.exit().transition().duration(200).attr('r', 0).remove();
        pts.transition().duration(200)
          .attr('cx', d => xScale(d.date))
          .attr('cy', d => yScale(d.mean));
        pts.enter().append('circle').attr('class', 'point')
          .attr('cx', d => xScale(d.date))
          .attr('cy', d => yScale(d.mean))
          .attr('r', 0)
          .transition().delay(50).duration(200).attr('r', 4);

        // tooltip
        pointGroup.selectAll('circle')
          .on('mouseover', (event, d) => {
            d3.select(event.currentTarget).transition().duration(100).attr('r', 6);
            let label;
            if (currentRes === 'quarterly') {
              const start = d.date;
              const end = new Date(d.date.getFullYear(), d.date.getMonth() + 2, 1);
              label = `${fmtMonth(start)}-${fmtMonth(end)} ${d.date.getFullYear()}`;
            } else if (currentRes === 'semiannual') {
              const start = d.date;
              const end = new Date(d.date.getFullYear(), d.date.getMonth() + 5, 1);
              label = `${fmtMonth(start)}-${fmtMonth(end)} ${d.date.getFullYear()}`;
            } else {
              label = `${d.date.getFullYear()}`;
            }
            tooltip.style('opacity', 1).html(`${label}<br><strong>Media giornaliera:</strong> ${d.mean.toFixed(2)}`);
          })
          .on('mousemove', event => {
            tooltip.style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 28) + 'px');
          })
          .on('mouseout', event => {
            d3.select(event.currentTarget).transition().duration(100).attr('r', 4);
            tooltip.style('opacity', 0);
          });
      }
    }).catch(err => console.error('Errore:', err));
  </script>
</body>
</html>
